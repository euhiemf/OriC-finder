// Generated by CoffeeScript 1.9.0
(function() {
  var ClumpTraverser, Traverser, dna, i, max, namespace, reverseComplement, seq, _i, _ref;

  dna = "CGGACTCGACAGATGTGAAGAACGACAATGTGAAGACTCGACACGACAGAGTGAAGAGAAGAGGAAACATTGTAA";

  window.tree = {
    branches: {}
  };

  window.k = 6;

  namespace = function(start_point, string) {
    var b, index, ns, p, _i, _len;
    ns = string.split('');
    b = tree;
    for (index = _i = 0, _len = ns.length; _i < _len; index = ++_i) {
      p = ns[index];
      if (b.branches.hasOwnProperty(p)) {
        b = b.branches[p];
      } else {
        b.branches[p] = {
          spts: [],
          branches: {},
          value: p
        };
        b = b.branches[p];
      }
      b.spts.push(index + start_point);
    }
    return tree[ns[0]];
  };

  window.traverseCommander = {
    funcs: [],
    listen: function(f, context) {
      if (context == null) {
        context = null;
      }
      this.funcs.push({
        func: f,
        context: context
      });
      return this.funcs.length - 1;
    },
    dismiss: function(i) {
      return this.funcs[i] = false;
    },
    walk: function(n) {
      var i, _i, _results;
      if (n == null) {
        n = 1;
      }
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        _results.push(this.funcs.forEach(function(f) {
          if (f) {
            return f.func.call(f.context);
          }
        }));
      }
      return _results;
    }
  };

  window.traverser_list_of_success = [];

  Traverser = (function() {
    Traverser.prototype.paths = [];

    function Traverser(_at_start, _at_sequence) {
      this.start = _at_start;
      this.sequence = _at_sequence;
      traverseCommander.listen(this.walk, this);
      this.paths.push({
        distance_traveled: -1,
        stroll: [],
        tollerance: 2,
        branches: tree.branches
      });
    }

    Traverser.prototype.spawn = function(parent_path) {
      var branches, key, stroll, val, _ref, _results;
      _ref = parent_path.branches;
      _results = [];
      for (key in _ref) {
        val = _ref[key];
        stroll = parent_path.stroll.concat(key);
        branches = val.branches;
        _results.push(this.paths.push({
          distance_traveled: parent_path.distance_traveled,
          tollerance: parent_path.tollerance,
          stroll: stroll,
          branches: branches
        }));
      }
      return _results;
    };

    Traverser.prototype.candidates = [];

    Traverser.prototype.end = function(path) {
      var key, val, _results;
      if (!path.hasOwnProperty('branches')) {
        return this.candidates.push(path);
      } else {
        _results = [];
        for (key in path) {
          val = path[key];
          _results.push(this.candidates.push(val));
        }
        return _results;
      }
    };

    Traverser.prototype.walk = function() {
      var addition, current_bp, deletion, i, index, path, _i, _j, _k, _len, _len1, _len2, _ref, _results;
      addition = [];
      deletion = [];
      _ref = this.paths;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        path = _ref[index];
        path.distance_traveled++;
        current_bp = this.sequence[path.distance_traveled];
        if (!current_bp) {
          console.count();
          continue;
        }
        if (path.branches.hasOwnProperty(current_bp)) {
          path.stroll.push(current_bp);
          path.branches = path.branches[current_bp].branches;
          if (path.distance_traveled >= (k - 1)) {
            if (!path.branches[current_bp]) {
              debugger;
            }
          }
          this.end(path.branches[current_bp]);
          deletion.push(index);
        } else if (path.tollerance > 0) {
          path.tollerance--;
          if (Object.keys(path.branches).length > 1) {
            if (path.distance_traveled >= (k - 1)) {
              this.end(path.branches);
              deletion.push(index);
              console.count();
            } else {
              addition.push(index);
            }
          } else {
            deletion.push(index);
          }
        } else {
          deletion.push(index);
        }
      }
      for (_j = 0, _len1 = addition.length; _j < _len1; _j++) {
        index = addition[_j];
        this.spawn(this.paths[index]);
        deletion.push(index);
      }
      _results = [];
      for (_k = 0, _len2 = deletion.length; _k < _len2; _k++) {
        i = deletion[_k];
        _results.push(this.paths.splice(i, 1));
      }
      return _results;
    };

    return Traverser;

  })();

  max = 0;

  reverseComplement = function(string) {
    var complements, i, ns, _i, _len;
    complements = {
      "A": "T",
      "T": "A",
      "G": "C",
      "C": "G"
    };
    ns = "";
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      i = string[_i];
      ns = complements[i] + ns;
    }
    return ns;
  };

  ClumpTraverser = (function() {
    function ClumpTraverser(_at_sequence, _at_start_point, threshold) {
      var base_tollerance, bp, val, _ref;
      this.sequence = _at_sequence;
      this.start_point = _at_start_point;
      if (threshold == null) {
        threshold = 1;
      }
      this.paths = [];
      this.distance_traveled = 0;
      base_tollerance = threshold + 1;
      _ref = tree.branches;
      for (bp in _ref) {
        val = _ref[bp];
        this.spawn({
          tollerance: this.sequence[this.distance_traveled] === bp ? base_tollerance : base_tollerance - 1,
          subpath: val.branches,
          bp: bp,
          spts: val.spts,
          stroll: [bp]
        });
      }
      this.commander_id = traverseCommander.listen(this.walk, this);
    }

    ClumpTraverser.prototype.spawn = function(ob) {
      return this.paths.push(ob);
    };

    ClumpTraverser.prototype.walk = function() {
      var bp, deletion, index, path, subpath, ts, _i, _len, _ref, _ref1;
      this.distance_traveled++;
      deletion = [];
      _ref = this.paths;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        path = _ref[index];
        path["delete"] = true;
        _ref1 = path.subpath;
        for (bp in _ref1) {
          subpath = _ref1[bp];
          ts = {
            tollerance: this.sequence[this.distance_traveled] === bp ? path.tollerance : path.tollerance - 1,
            subpath: subpath.branches,
            bp: bp,
            spts: subpath.spts,
            stroll: path.stroll.concat(bp)
          };
          this.spawn(ts);
        }
      }
      this.paths = _.reject(this.paths, function(ob) {
        return !!ob["delete"];
      });
      this.validatePaths();
      if (this.distance_traveled >= k - 1) {
        return this.end();
      }
    };

    ClumpTraverser.prototype.validatePaths = function() {
      var deletion, index, path, _i, _len, _ref;
      deletion = [];
      _ref = this.paths;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        path = _ref[index];
        if (path.tollerance <= 0) {
          path["delete"] = true;
        }
      }
      return this.paths = _.reject(this.paths, function(ob) {
        return !!ob["delete"];
      });
    };

    ClumpTraverser.prototype.end = function() {
      var i, index, strolls, _i, _len;
      if (this.paths.length >= max) {
        strolls = _.pluck(this.paths, 'stroll');
        for (index = _i = 0, _len = strolls.length; _i < _len; index = ++_i) {
          i = strolls[index];
          strolls[index] = i.join('');
        }
        window.traverser_list_of_success.push({
          count: this.paths.length,
          seq: this.sequence,
          strolls: strolls,
          ob: this
        });
        if (this.paths.length > max) {
          max = this.paths.length;
        }
      }
      return traverseCommander.dismiss(this.commander_id);
    };

    return ClumpTraverser;

  })();

  window.tlist = [];

  for (i = _i = 0, _ref = dna.length - k; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    seq = dna.substr(i, k);
    namespace(i, seq);
    traverseCommander.walk();
    tlist.push(new ClumpTraverser(seq, i, 2));
    tlist.push(new ClumpTraverser(reverseComplement(seq), i, 2));
  }

  traverseCommander.walk(k);

  window.traverser_list_of_success = _.reject(window.traverser_list_of_success, function(ob) {
    return ob.count < max - 1;
  });

  window.max_s = [];

  window.traverser_list_of_success.forEach(function(ob) {
    return window.max_s = window.max_s.concat(ob.strolls);
  });

  window.max_s = _.uniq(window.max_s);

  console.log(max);

  console.log(window.max_s);

}).call(this);

//# sourceMappingURL=traverser.js.map
