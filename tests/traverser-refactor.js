// Generated by CoffeeScript 1.9.1
(function() {
  var CandidateFilter, EventListener, Traverser, dna, filter, i, input, j, k, namespace, ref, reverseComplement, seq, tlist, traverseCommander, tree;

  input = {
    DNA: {
      lines: ["CGGACTCGACAGATGTGAAGAACGACAATGTGAAGACTCGACACGACAGAGTGAAGAGAAGAGGAAACATTGTAA"],
      line_length: 50
    },
    window_size: 100,
    mutation_threshold: 2
  };

  k = 5;

  tree = {
    branches: {}
  };

  namespace = function(start_point, string) {
    var b, index, j, len, ns, p, spts;
    ns = string.split('');
    b = tree;
    for (index = j = 0, len = ns.length; j < len; index = ++j) {
      p = ns[index];
      if (b.branches.hasOwnProperty(p)) {
        b = b.branches[p];
      } else {
        b.branches[p] = {
          spts: [],
          branches: {},
          value: p
        };
        b = b.branches[p];
      }
      spts = index + start_point;
      b.maxspts = spts;
      b.spts.push(spts);
    }
    return tree[ns[0]];
  };

  EventListener = (function() {
    function EventListener() {}

    EventListener.prototype.funcs = [];

    EventListener.prototype.listen = function(f, context) {
      if (context == null) {
        context = null;
      }
      this.funcs.push({
        func: f,
        context: context
      });
      return this.funcs.length - 1;
    };

    EventListener.prototype.dismiss = function(i) {
      return this.funcs[i] = false;
    };

    EventListener.prototype.walk = function(n) {
      var f, i, j, ref, results;
      if (n == null) {
        n = 1;
      }
      results = [];
      for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var l, len, ref1, results1;
          ref1 = this.funcs;
          results1 = [];
          for (l = 0, len = ref1.length; l < len; l++) {
            f = ref1[l];
            if (f) {
              results1.push(f.func.call(f.context));
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return EventListener;

  })();

  reverseComplement = function(string) {
    var complements, i, j, len, ns;
    complements = {
      "A": "T",
      "T": "A",
      "G": "C",
      "C": "G"
    };
    ns = "";
    for (j = 0, len = string.length; j < len; j++) {
      i = string[j];
      ns = complements[i] + ns;
    }
    return ns;
  };

  CandidateFilter = (function() {
    CandidateFilter.prototype.max_candidates = [];

    function CandidateFilter() {
      this;
    }

    CandidateFilter.prototype.max = 0;

    CandidateFilter.prototype.push = function(traverser) {
      var candidate, i, j, len, ref;
      if (traverser.paths.length >= this.max - 1) {
        if (traverser.paths.length > this.max) {
          this.max++;
          this.max_candidates = _.filter(this.max_candidates, function(candidate) {
            return candidate.rank >= this.max - 1;
          });
        }
        candidate = {
          rank: traverser.paths.length + 1,
          sequences: [traverser.sequence],
          reverse_complement: traverser.reverse_complement
        };
        ref = traverser.paths;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          candidate.sequences.push(i.stroll.join(""));
        }
        return this.max_candidates.push(candidate);
      }
    };

    CandidateFilter.prototype.clean = function() {
      var candidate, j, len, ref, results;
      ref = this.max_candidates;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        candidate = ref[j];
        candidate.sequences = _.uniq(candidate.sequences);
        results.push(candidate.rank = candidate.sequences.length);
      }
      return results;
    };

    return CandidateFilter;

  })();

  filter = window.filter = new CandidateFilter();

  Traverser = (function() {
    function Traverser(sequence, start_point1, threshold, reverse_complement) {
      var base_tollerance, bp, ref, subpath;
      this.sequence = sequence;
      this.start_point = start_point1;
      if (threshold == null) {
        threshold = 1;
      }
      this.reverse_complement = reverse_complement != null ? reverse_complement : false;
      this.paths = [];
      this.distance_traveled = 0;
      base_tollerance = threshold + 1;
      this.commander_id = traverseCommander.listen(this.walk, this);
      ref = tree.branches;
      for (bp in ref) {
        subpath = ref[bp];
        this.spawn({
          tollerance: this.isTollerated(bp) ? base_tollerance : base_tollerance - 1,
          subpath: subpath.branches,
          bp: bp,
          spts: subpath.spts,
          stroll: [bp]
        });
      }
    }

    Traverser.prototype.isOutOfRange = function(maxspts, stroll) {
      var lower, upper;
      lower = maxspts < this.start_point - input.window_size;
      upper = this.start_point < k;
      return lower || upper;
    };

    Traverser.prototype.isTollerated = function(bp) {
      return this.sequence[this.distance_traveled] === bp;
    };

    Traverser.prototype.spawn = function(ob) {
      return this.paths.push(ob);
    };

    Traverser.prototype.walk = function() {
      var bp, deletion, index, j, len, path, ref, ref1, subpath, ts;
      this.distance_traveled++;
      deletion = [];
      ref = this.paths;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        path = ref[index];
        path["delete"] = true;
        ref1 = path.subpath;
        for (bp in ref1) {
          subpath = ref1[bp];
          if (this.isOutOfRange(subpath.maxspts, path.stroll.join(''))) {
            continue;
          }
          ts = {
            tollerance: this.isTollerated(bp) ? path.tollerance : path.tollerance - 1,
            subpath: subpath.branches,
            bp: bp,
            spts: subpath.spts,
            stroll: path.stroll.concat(bp)
          };
          this.spawn(ts);
        }
      }
      this.paths = _.reject(this.paths, function(ob) {
        return !!ob["delete"];
      });
      this.validatePaths();
      if (this.distance_traveled >= k - 1) {
        return this.end();
      }
    };

    Traverser.prototype.validatePaths = function() {
      var deletion, index, j, len, path, ref;
      deletion = [];
      ref = this.paths;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        path = ref[index];
        if (path.tollerance <= 0) {
          path["delete"] = true;
        }
      }
      return this.paths = _.reject(this.paths, function(ob) {
        return !!ob["delete"];
      });
    };

    Traverser.prototype.end = function() {
      filter.push(this);
      return traverseCommander.dismiss(this.commander_id);
    };

    return Traverser;

  })();

  traverseCommander = new EventListener();

  window.tlist = tlist = [];

  dna = input.DNA.lines.join('');

  console.log("DNA length: ", dna.length);

  for (i = j = 0, ref = dna.length - k; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    seq = dna.substr(i, k);
    namespace(i, seq);
    traverseCommander.walk();
    tlist.push(new Traverser(seq, i, 2));
    tlist.push(new Traverser(reverseComplement(seq), i, 2, true));
  }

  traverseCommander.walk(k);

  filter.clean();

  console.log(filter);

}).call(this);

//# sourceMappingURL=traverser-refactor.js.map
