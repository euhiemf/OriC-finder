// Generated by CoffeeScript 1.9.0
(function() {
  var EventListener, Traverser, dna, i, input, k, namespace, reverseComplement, seq, tlist, traverseCommander, tree, _i, _ref;

  input = {
    DNA: {
      lines: ["ACAAGATGCCATTGTCCCCCGGCCTCCTGCTGCTGCTGCTCTCCGGGGCCACGGCCACCGCTGCCCTGCC", "CCTGGAGGGTGGCCCCACCGGCCGAGACAGCGAGCATATGCAGGAAGCGGCAGGAATAAGGAAAAGCAGC", "CTCCTGACTTTCCTCGCTTGGTGGTTTGAGTGGACCTCCCAGGCCAGTGCCGGGCCCCTCATAGGAGAGG", "AAGCTCGGGAGGTGGCCAGGCGGCAGGAAGGCGCACCCCCCCAGCAATCCGCGCGCCGGGACAGAATGCC", "CTGCAGGAACTTCTTCTGGAAGACCTTCTCCTCCTGCAAATAAAACCTCACCCATGAATGCTCACGCAAG", "TTTAATTACAGACCTGAA"],
      line_length: 70
    },
    window_size: 150,
    mutation_threshold: 2
  };

  tree = {
    branches: {}
  };

  namespace = function(start_point, string) {
    var b, index, ns, p, spts, _i, _len;
    ns = string.split('');
    b = tree;
    for (index = _i = 0, _len = ns.length; _i < _len; index = ++_i) {
      p = ns[index];
      if (b.branches.hasOwnProperty(p)) {
        b = b.branches[p];
      } else {
        b.branches[p] = {
          spts: [],
          branches: {},
          value: p
        };
        b = b.branches[p];
      }
      spts = index + start_point;
      b.maxspts = spts;
      b.spts.push(spts);
    }
    return tree[ns[0]];
  };

  EventListener = (function() {
    function EventListener() {}

    EventListener.prototype.funcs = [];

    EventListener.prototype.listen = function(f, context) {
      if (context == null) {
        context = null;
      }
      this.funcs.push({
        func: f,
        context: context
      });
      return this.funcs.length - 1;
    };

    EventListener.prototype.dismiss = function(i) {
      return this.funcs[i] = false;
    };

    EventListener.prototype.walk = function(n) {
      var f, i, _i, _results;
      if (n == null) {
        n = 1;
      }
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        _results.push((function() {
          var _j, _len, _ref, _results1;
          _ref = this.funcs;
          _results1 = [];
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            f = _ref[_j];
            if (f) {
              _results1.push(f.func.call(f.context));
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return EventListener;

  })();

  reverseComplement = function(string) {
    var complements, i, ns, _i, _len;
    complements = {
      "A": "T",
      "T": "A",
      "G": "C",
      "C": "G"
    };
    ns = "";
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      i = string[_i];
      ns = complements[i] + ns;
    }
    return ns;
  };

  Traverser = (function() {
    function Traverser(_at_sequence, _at_start_point, threshold, _at_reverse_complement) {
      var base_tollerance, bp, subpath, _ref;
      this.sequence = _at_sequence;
      this.start_point = _at_start_point;
      if (threshold == null) {
        threshold = 1;
      }
      this.reverse_complement = _at_reverse_complement != null ? _at_reverse_complement : false;
      this.paths = [];
      this.distance_traveled = 0;
      base_tollerance = threshold + 1;
      this.commander_id = traverseCommander.listen(this.walk, this);
      _ref = tree.branches;
      for (bp in _ref) {
        subpath = _ref[bp];
        this.spawn({
          tollerance: this.isTollerated(bp) ? base_tollerance : base_tollerance - 1,
          subpath: subpath.branches,
          bp: bp,
          spts: subpath.spts,
          stroll: [bp]
        });
      }
    }

    Traverser.prototype.isOutOfRange = function(maxspts, stroll) {
      var lower, upper;
      lower = maxspts < this.start_point - input.window_size;
      upper = maxspts >= this.start_point || this.start_point < k;
      return lower || upper;
    };

    Traverser.prototype.isTollerated = function(bp) {
      return this.sequence[this.distance_traveled] === bp;
    };

    Traverser.prototype.spawn = function(ob) {
      return this.paths.push(ob);
    };

    Traverser.prototype.walk = function() {
      var bp, deletion, index, path, subpath, ts, _i, _len, _ref, _ref1;
      this.distance_traveled++;
      deletion = [];
      _ref = this.paths;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        path = _ref[index];
        path["delete"] = true;
        _ref1 = path.subpath;
        for (bp in _ref1) {
          subpath = _ref1[bp];
          if (this.isOutOfRange(subpath.maxspts, path.stroll.join(''))) {
            continue;
          }
          ts = {
            tollerance: this.isTollerated(bp) ? path.tollerance : path.tollerance - 1,
            subpath: subpath.branches,
            bp: bp,
            spts: subpath.spts,
            stroll: path.stroll.concat(bp)
          };
          this.spawn(ts);
        }
      }
      this.paths = _.reject(this.paths, function(ob) {
        return !!ob["delete"];
      });
      this.validatePaths();
      if (this.distance_traveled >= k - 1) {
        return this.end();
      }
    };

    Traverser.prototype.validatePaths = function() {
      var deletion, index, path, _i, _len, _ref;
      deletion = [];
      _ref = this.paths;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        path = _ref[index];
        if (path.tollerance <= 0) {
          path["delete"] = true;
        }
      }
      return this.paths = _.reject(this.paths, function(ob) {
        return !!ob["delete"];
      });
    };

    Traverser.prototype.end = function() {
      var i, _i, _len, _ref;
      if (this.paths.length >= 3) {
        console.log(this);
        console.log(this.sequence);
        _ref = this.paths;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          console.log(i.stroll.join(""));
        }
      }
      return traverseCommander.dismiss(this.commander_id);
    };

    return Traverser;

  })();

  traverseCommander = new EventListener();

  window.tlist = tlist = [];

  dna = input.DNA.lines.join('');

  k = 9;

  console.log("DNA length: ", dna.length);

  for (i = _i = 0, _ref = dna.length - k; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    seq = dna.substr(i, k);
    namespace(i, seq);
    traverseCommander.walk();
    tlist.push(new Traverser(seq, i, 2));
    tlist.push(new Traverser(reverseComplement(seq), i, 2, true));
  }

  traverseCommander.walk(k);

  console.log(tree);

}).call(this);

//# sourceMappingURL=traverser-refactor.js.map
